<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Treemap Visualizations</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js" async defer></script>
    <style>
        /* Flexbox container to display rows of treemaps */
        .treemap-row {
            display: flex;
            width: 100%;
            justify-content: space-around;
            margin-bottom: 20px;
        }

        /* Style for each treemap container */
        .treemap-container {
            width: 48%;
            height: 100vh;
        }
    </style>
</head>

<body>
    <div id="treemapRow1" class="treemap-row">
        <div id="treemap1" class="treemap-container"></div>
        <div id="treemap2" class="treemap-container"></div>
    </div>
    <div id="treemapRow2" class="treemap-row">
        <div id="treemap3" class="treemap-container"></div>
        <div id="treemap4" class="treemap-container"></div>
    </div>
    <div id="treemapRow3" class="treemap-row">
        <div id="treemap5" class="treemap-container"></div>
        <div id="treemap6" class="treemap-container"></div>
    </div>
    <div id="treemapRow4" class="treemap-row">
        <div id="treemap7" class="treemap-container"></div>
        <div id="treemap8" class="treemap-container"></div>
    </div>
    <div id="treemapRow5" class="treemap-row">
        <div id="treemap9" class="treemap-container"></div>
        <div id="treemap10" class="treemap-container"></div>
    </div>
    <div id="treemapRow5" class="treemap-row">
        <div id="treemap11" class="treemap-container"></div>
        <div id="treemap12" class="treemap-container"></div>
    </div>

    <script async>
        async function loadTreemaps() {
            try {
                // Load JSON data and parse it
                const response = await fetch('treemap_data.json');
                const data = await response.json();

                const limitedData = data.slice(0, 1248021); // Adjust slice to limit data

                // Treemap 1: App Categories with Minimum Installs
                const categories = {};
                limitedData.forEach(item => {
                    const category = item['Category'] || 'Unknown';
                    const appName = item['App Name'] || 'Unnamed App';
                    const installs = Number(item['Minimum Installs']) || 1;

                    if (!categories[category]) {
                        categories[category] = { apps: [], totalInstalls: 0 };
                    }
                    categories[category].apps.push({ name: appName, installs });
                    categories[category].totalInstalls += installs;
                });

                const categoryLabels = ["All Apps", ...Object.keys(categories)];
                const categoryParents = ["", ...Object.keys(categories).map(() => "All Apps")];
                const categoryValues = [null, ...Object.values(categories).map(cat => cat.totalInstalls)];

                const categoryTrace = {
                    type: 'treemap',
                    labels: categoryLabels,
                    parents: categoryParents,
                    values: categoryValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value'
                };

                const categoryLayout = {
                    title: 'App Category Treemap',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap1', [categoryTrace], categoryLayout);

                // Treemap 2: Content Rating with Minimum Installs
                const contentratings = {};
                limitedData.forEach(item => {
                    const category = item['Content Rating'] || 'Unknown';
                    const appName = item['App Name'] || 'Unnamed App';
                    const installs = Number(item['Minimum Installs']) || 1;

                    if (!contentratings[category]) {
                        contentratings[category] = { apps: [], totalInstalls: 0 };
                    }
                    contentratings[category].apps.push({ name: appName, installs });
                    contentratings[category].totalInstalls += installs;
                });

                const crLabels = ["All Apps", ...Object.keys(contentratings)];
                const crParents = ["", ...Object.keys(contentratings).map(() => "All Apps")];
                const crValues = [null, ...Object.values(contentratings).map(cat => cat.totalInstalls)];

                const crTrace = {
                    type: 'treemap',
                    labels: crLabels,
                    parents: crParents,
                    values: crValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value'
                };

                const crLayout = {
                    title: 'Content Rating Treemap',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap2', [crTrace], crLayout);


                // Additional Treemap 3: Ad Supported with Minimum Installs
                const adSupportedData = {};
                limitedData.forEach(item => {
                    const adSupported = item['Ad Supported'] || false;
                    const installs = Number(item['Minimum Installs']) || 1;

                    if (!adSupportedData[adSupported]) {
                        adSupportedData[adSupported] = { totalInstalls: 0 };
                    }
                    adSupportedData[adSupported].totalInstalls += installs;
                });

                const adLabels = ["All Apps", ...Object.keys(adSupportedData)];
                const adParents = ["", ...Object.keys(adSupportedData).map(() => "All Apps")];
                const adValues = [null, ...Object.values(adSupportedData).map(ad => ad.totalInstalls)];

                const adTrace = {
                    type: 'treemap',
                    labels: adLabels,
                    parents: adParents,
                    values: adValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value'
                };

                Plotly.newPlot('treemap3', [adTrace], {
                    title: 'Ad Supported Apps',
                    height: 600,
                    width: 800
                });

                // Additional Treemap 4: Price Categories
                const freeData = {};
                limitedData.forEach(item => {
                    const adSupported = item['Free'] || false;
                    const installs = Number(item['Minimum Installs']) || 1;

                    if (!adSupportedData[adSupported]) {
                        adSupportedData[adSupported] = { totalInstalls: 0 };
                    }
                    adSupportedData[adSupported].totalInstalls += installs;
                });

                const freeLabels = ["All Apps", ...Object.keys(adSupportedData)];
                const freeParents = ["", ...Object.keys(adSupportedData).map(() => "All Apps")];
                const freeValues = [null, ...Object.values(adSupportedData).map(ad => ad.totalInstalls)];

                const freeTrace = {
                    type: 'treemap',
                    labels: freeLabels,
                    parents: freeParents,
                    values: freeValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value'
                };

                Plotly.newPlot('treemap4', [freeTrace], {
                    title: 'Free vs Paid Apps',
                    height: 600,
                    width: 800
                });

                // Additional Treemap 5: In app purchases
                const inappData = {};
                limitedData.forEach(item => {
                    const adSupported = item['In App Purchases'] || false;
                    const installs = Number(item['Minimum Installs']) || 1;

                    if (!adSupportedData[adSupported]) {
                        adSupportedData[adSupported] = { totalInstalls: 0 };
                    }
                    adSupportedData[adSupported].totalInstalls += installs;
                });

                const inappLabels = ["All Apps", ...Object.keys(adSupportedData)];
                const inappParents = ["", ...Object.keys(adSupportedData).map(() => "All Apps")];
                const inappValues = [null, ...Object.values(adSupportedData).map(ad => ad.totalInstalls)];

                const inappTrace = {
                    type: 'treemap',
                    labels: inappLabels,
                    parents: inappParents,
                    values: inappValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value'
                };

                Plotly.newPlot('treemap5', [inappTrace], {
                    title: 'In app purchases available or not',
                    height: 600,
                    width: 800
                });

                // Tree map 6: Category and Free
                const categoryfree = {};
                limitedData.forEach(item => {
                    const category = item['Category'] || 'Unknown Category';

                    // Check for any truthy value that is not explicitly "False" to set as "True"
                    const inAppPurchases = item['Free'] && item['Free'].toString().toLowerCase() !== "false" ? 'True' : 'False';

                    // Initialize category if it doesn't exist
                    if (!categoryfree[category]) {
                        categoryfree[category] = { purchases: { 'True': { appCount: 0 }, 'False': { appCount: 0 } }, totalApps: 0 };
                    }

                    // Increment the app count for each In App Purchases status under the category
                    categoryfree[category].purchases[inAppPurchases].appCount += 1;
                    categoryfree[category].totalApps += 1;
                });

                // Prepare data for Plotly treemap
                const cfLabels = ["All Apps"];
                const cfParents = [""];
                const cfValues = [null];

                // Loop over categories and In App Purchases to populate labels, parents, and values
                Object.keys(categoryfree).forEach(category => {
                    cfLabels.push(category);
                    cfParents.push("All Apps");
                    cfValues.push(categoryfree[category].totalApps);

                    Object.keys(categoryfree[category].purchases).forEach(inAppPurchases => {
                        cfLabels.push(`${category} - ${inAppPurchases}`);
                        cfParents.push(category);
                        cfValues.push(categoryfree[category].purchases[inAppPurchases].appCount);
                    });
                });

                const cfTrace = {
                    type: 'treemap',
                    labels: cfLabels,
                    parents: cfParents,
                    values: cfValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value+percent parent'
                };

                const cfLayout = {
                    title: 'Category and Free Treemap',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap6', [cfTrace], cfLayout);

                // Tree map 7: Category and Content Rating
                const contentcategory = {};
                limitedData.forEach(item => {
                    const category = item['Category'] || 'Unknown Category';
                    const contentRating = item['Content Rating'] || 'Unknown Rating';
                    const installs = Number(item['Minimum Installs']) || 1;

                    // Initialize category if it doesn't exist
                    if (!contentcategory[category]) {
                        contentcategory[category] = { ratings: {}, totalInstalls: 0 };
                    }

                    // Initialize content rating under the category if it doesn't exist
                    if (!contentcategory[category].ratings[contentRating]) {
                        contentcategory[category].ratings[contentRating] = { totalInstalls: 0 };
                    }

                    // Increment installs for each content rating under the category
                    contentcategory[category].ratings[contentRating].totalInstalls += installs;
                    contentcategory[category].totalInstalls += installs;
                });

                // Prepare data for Plotly treemap
                const ccLabels = ["All Apps"];
                const ccParents = [""];
                const ccValues = [null];

                // Loop over categories and content ratings to populate labels, parents, and values
                Object.keys(contentcategory).forEach(category => {
                    ccLabels.push(category);
                    ccParents.push("All Apps");
                    ccValues.push(contentcategory[category].totalInstalls);

                    Object.keys(contentcategory[category].ratings).forEach(contentRating => {
                        ccLabels.push(contentRating);
                        ccParents.push(category);
                        ccValues.push(contentcategory[category].ratings[contentRating].totalInstalls);
                    });
                });

                const ccTrace = {
                    type: 'treemap',
                    labels: ccLabels,
                    parents: ccParents,
                    values: ccValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value'
                };

                const ccLayout = {
                    title: 'Category and Content Rating Treemap',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap7', [ccTrace], ccLayout);

                // Tree map 8: Category and In App Purchases
                const categoryInApp = {};
                limitedData.forEach(item => {
                    const category = item['Category'] || 'Unknown Category';

                    // Check for any truthy value that is not explicitly "False" to set as "True"
                    const inAppPurchases = item['In App Purchases'] && item['In App Purchases'].toString().toLowerCase() !== "false" ? 'True' : 'False';

                    // Initialize category if it doesn't exist
                    if (!categoryInApp[category]) {
                        categoryInApp[category] = { purchases: { 'True': { appCount: 0 }, 'False': { appCount: 0 } }, totalApps: 0 };
                    }

                    // Increment the app count for each In App Purchases status under the category
                    categoryInApp[category].purchases[inAppPurchases].appCount += 1;
                    categoryInApp[category].totalApps += 1;
                });

                // Prepare data for Plotly treemap
                const ciLabels = ["All Apps"];
                const ciParents = [""];
                const ciValues = [null];

                // Loop over categories and In App Purchases to populate labels, parents, and values
                Object.keys(categoryInApp).forEach(category => {
                    ciLabels.push(category);
                    ciParents.push("All Apps");
                    ciValues.push(categoryInApp[category].totalApps);

                    Object.keys(categoryInApp[category].purchases).forEach(inAppPurchases => {
                        ciLabels.push(`${category} - ${inAppPurchases}`);
                        ciParents.push(category);
                        ciValues.push(categoryInApp[category].purchases[inAppPurchases].appCount);
                    });
                });

                const ciTrace = {
                    type: 'treemap',
                    labels: ciLabels,
                    parents: ciParents,
                    values: ciValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value+percent parent'
                };

                const ciLayout = {
                    title: 'Category and In App Purchases Treemap',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap8', [ciTrace], ciLayout);

                // Tree map 9: Category and Ad Supported
                const categoryAd = {};
                limitedData.forEach(item => {
                    const category = item['Category'] || 'Unknown Category';

                    // Check for any truthy value that is not explicitly "False" to set as "True"
                    const inAppPurchases = item['Ad Supported'] && item['Ad Supported'].toString().toLowerCase() !== "false" ? 'True' : 'False';

                    // Initialize category if it doesn't exist
                    if (!categoryAd[category]) {
                        categoryAd[category] = { purchases: { 'True': { appCount: 0 }, 'False': { appCount: 0 } }, totalApps: 0 };
                    }

                    // Increment the app count for each In App Purchases status under the category
                    categoryAd[category].purchases[inAppPurchases].appCount += 1;
                    categoryAd[category].totalApps += 1;
                });

                // Prepare data for Plotly treemap
                const caLabels = ["All Apps"];
                const caParents = [""];
                const caValues = [null];

                // Loop over categories and In App Purchases to populate labels, parents, and values
                Object.keys(categoryAd).forEach(category => {
                    caLabels.push(category);
                    caParents.push("All Apps");
                    caValues.push(categoryInApp[category].totalApps);

                    Object.keys(categoryAd[category].purchases).forEach(inAppPurchases => {
                        caLabels.push(`${category} - ${inAppPurchases}`);
                        caParents.push(category);
                        caValues.push(categoryInApp[category].purchases[inAppPurchases].appCount);
                    });
                });

                const caTrace = {
                    type: 'treemap',
                    labels: caLabels,
                    parents: caParents,
                    values: caValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value+percent parent'
                };

                const caLayout = {
                    title: 'Category and Ad Supported Treemap',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap9', [caTrace], caLayout);

                // Tree map 10: Content Rating and Ad Supported
                const contentAd = {};
                limitedData.forEach(item => {
                    const category = item['Content Rating'] || 'Unknown Rating';

                    // Check for any truthy value that is not explicitly "False" to set as "True"
                    const inAppPurchases = item['Ad Supported'] && item['Ad Supported'].toString().toLowerCase() !== "false" ? 'True' : 'False';

                    // Initialize category if it doesn't exist
                    if (!contentAd[category]) {
                        contentAd[category] = { purchases: { 'True': { appCount: 0 }, 'False': { appCount: 0 } }, totalApps: 0 };
                    }

                    // Increment the app count for each In App Purchases status under the category
                    contentAd[category].purchases[inAppPurchases].appCount += 1;
                    contentAd[category].totalApps += 1;
                });

                // Prepare data for Plotly treemap
                const coaLabels = ["All Apps"];
                const coaParents = [""];
                const coaValues = [null];

                // Loop over categories and In App Purchases to populate labels, parents, and values
                Object.keys(contentAd).forEach(category => {
                    coaLabels.push(category);
                    coaParents.push("All Apps");
                    coaValues.push(contentAd[category].totalApps);

                    Object.keys(contentAd[category].purchases).forEach(inAppPurchases => {
                        coaLabels.push(`${category} - ${inAppPurchases}`);
                        coaParents.push(category);
                        coaValues.push(contentAd[category].purchases[inAppPurchases].appCount);
                    });
                });

                const coaTrace = {
                    type: 'treemap',
                    labels: coaLabels,
                    parents: coaParents,
                    values: coaValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value+percent parent'
                };

                const coaLayout = {
                    title: 'Content Rating and Ad Supported Treemap',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap10', [coaTrace], coaLayout);

                // Tree map 11: Content Rating and In App Purchases
                const contentInApp = {};
                limitedData.forEach(item => {
                    const category = item['Content Rating'] || 'Unknown Rating';

                    // Check for any truthy value that is not explicitly "False" to set as "True"
                    const inAppPurchases = item['In App Purchases'] && item['In App Purchases'].toString().toLowerCase() !== "false" ? 'True' : 'False';

                    // Initialize category if it doesn't exist
                    if (!contentInApp[category]) {
                        contentInApp[category] = { purchases: { 'True': { appCount: 0 }, 'False': { appCount: 0 } }, totalApps: 0 };
                    }

                    // Increment the app count for each In App Purchases status under the category
                    contentInApp[category].purchases[inAppPurchases].appCount += 1;
                    contentInApp[category].totalApps += 1;
                });

                // Prepare data for Plotly treemap
                const coiLabels = ["All Apps"];
                const coiParents = [""];
                const coiValues = [null];

                // Loop over categories and In App Purchases to populate labels, parents, and values
                Object.keys(contentAd).forEach(category => {
                    coiLabels.push(category);
                    coiParents.push("All Apps");
                    coiValues.push(contentInApp[category].totalApps);

                    Object.keys(contentAd[category].purchases).forEach(inAppPurchases => {
                        coiLabels.push(`${category} - ${inAppPurchases}`);
                        coiParents.push(category);
                        coiValues.push(contentInApp[category].purchases[inAppPurchases].appCount);
                    });
                });

                const coiTrace = {
                    type: 'treemap',
                    labels: coiLabels,
                    parents: coiParents,
                    values: coiValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value+percent parent'
                };

                const coiLayout = {
                    title: 'Content Rating and In App Purchases',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap11', [coiTrace], coiLayout);

                // Tree map 12: Content Rating and Free
                const contentFree = {};
                limitedData.forEach(item => {
                    const category = item['Content Rating'] || 'Unknown Rating';

                    // Check for any truthy value that is not explicitly "False" to set as "True"
                    const inAppPurchases = item['Free'] && item['Free'].toString().toLowerCase() !== "false" ? 'True' : 'False';

                    // Initialize category if it doesn't exist
                    if (!contentFree[category]) {
                        contentFree[category] = { purchases: { 'True': { appCount: 0 }, 'False': { appCount: 0 } }, totalApps: 0 };
                    }

                    // Increment the app count for each In App Purchases status under the category
                    contentFree[category].purchases[inAppPurchases].appCount += 1;
                    contentFree[category].totalApps += 1;
                });

                // Prepare data for Plotly treemap
                const cofLabels = ["All Apps"];
                const cofParents = [""];
                const cofValues = [null];

                // Loop over categories and In App Purchases to populate labels, parents, and values
                Object.keys(contentFree).forEach(category => {
                    cofLabels.push(category);
                    cofParents.push("All Apps");
                    cofValues.push(contentFree[category].totalApps);

                    Object.keys(contentFree[category].purchases).forEach(inAppPurchases => {
                        cofLabels.push(`${category} - ${inAppPurchases}`);
                        cofParents.push(category);
                        cofValues.push(contentFree[category].purchases[inAppPurchases].appCount);
                    });
                });

                const cofTrace = {
                    type: 'treemap',
                    labels: cofLabels,
                    parents: cofParents,
                    values: cofValues,
                    textinfo: 'label+value+percent parent',
                    hoverinfo: 'label+value+percent parent'
                };

                const cofLayout = {
                    title: 'Content Rating and Free',
                    height: 600,
                    width: 800
                };

                Plotly.newPlot('treemap12', [cofTrace], cofLayout);

            } catch (error) {
                console.error('Error loading JSON data:', error);
            }
        }

        loadTreemaps();
    </script>
</body>

</html>